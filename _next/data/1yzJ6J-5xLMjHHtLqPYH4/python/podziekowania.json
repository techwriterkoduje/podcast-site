{"pageProps":{"guidePages":[{"pageId":"teoria","pageTitle":"Na początek trochę teorii","pageContent":"<p>Z doświadczenia wiem, że nikt nie lubi czytać wstępów. Jednak zachęcam Cię do\nprzeczytania tych kilku krótkich sekcji. Dzięki temu, zrozumiesz co, komu i w\njaki sposób chciałem przekazać za pomocą tego przewodnika.</p>\n<h2>Dla kogo jest ten przewodnik?</h2>\n<p>Dla osób zajmujących się tworzeniem dokumentacji do oprogramowania. Twoje\nstanowisko może mieć różne nazwy, ale ja dla uproszczenia będę się w tym\nprzewodniku posługiwał określeniem \"Tech Writer\".</p>\n<h2>Po co powstał ten przewodnik?</h2>\n<p>Moim celem nie jest zrobienie z Ciebie programisty. Nie dlatego, że nie jest to\nmożliwe, tylko dlatego, że jako Tech Writer wnosisz dużo do swojej organizacji.\nPoza tym, bycie programistą to coś więcej niż tylko nauczenie się składni\njakiegoś języka. To zestaw umiejętności oraz odpowiedni sposób myślenia. Tak\nsamo jest w przypadku pisania dokumentacji. Umiejętność pisania w dicie czy\nobsługi narzędzia typu HAT nie zrobi z Ciebie Tech Writera. Więc zostań tam\ngdzie jesteś.</p>\n<p>Moim celem jest zrobienie z Ciebie kodującego Tech Writera. Specjalnie używam\nsłowa \"kodować\" zamiast \"programować\", żeby jasno rozróżnić pomiędzy tym co robi\ntechniczny Tech Writer, a zawodowy programista. Nie staraj się zostać ekspertem\nw danym języku programowania. Potraktuj kodowanie jako narzędzie, które ułatwi\nCi osiąganie celów dokumentacyjnych. Niech to będzie kolejna umiejętność, która\nzrobi z Ciebie jeszcze lepszego Tech Writera.</p>\n<p>Ten przewodnik ma za zadanie wprowadzić Cię w świat kodowania w Pythonie i\nzachęcić Cię do pogłębiania wiedzy w tym obszarze. Dzięki temu łatwiej będzie Ci\ntworzyć praktyczne rozwiązania, które usprawnią proces tworzenia dokumentacji i\npozwolą Ci lepiej zintegrować się z tym co robią programiści w Twojej\norganizacji.</p>\n<h2>Dlaczego warto kodować?</h2>\n<p>Pewnie zastanawiasz się po co Ci kodowanie, skoro budowaniem aplikacji zajmuje\nsię ktoś inny, a Twoim zadaniem jest ich opisywanie. Nauka kodowania jest dla\nCiebie wartościowa z kilku powodów:</p>\n<ul>\n<li>Będziesz w stanie lepiej zrozumieć o czym mówią programiści. To na pewno\nułatwi Ci pracę.</li>\n<li>Ucząc się kodowania masz okazję korzystać z tych samych źródeł wiedzy co\nprogramiści. Dzięki temu lepiej zrozumiesz jak pracują i z jakimi wyzwaniami\nsię mierzą. To z kolei pozwoli Ci na łatwiejsze budowanie relacji z nimi. Poza\ntym łatwiej będzie Ci zagaić do nich przy kawie.</li>\n<li>Będziesz w stanie tworzyć rozwiązania, takie jak skrypty, które zautomatyzują\nnudną i powtarzalną część Twojej pracy. Na przykład, zamiast generować 10\nwersji dokumentu poprzez klikanie i czekanie a potem przenoszenie ich w\nmiejsce docelowe, napiszesz skrypt, który uruchomi budowanie dokumentów, a\npotem przekopiuje je gdzie trzeba. Przekazując takie zadania maszynie będziesz\nmieć więcej czasu na zajęcie się tym co jest ważne w pracy Tech Writera, a\nczego maszyna nie potrafi tak dobrze jak Ty, czyli tworzeniem użytecznej\ntreści.</li>\n<li>Jest to dobre ćwiczenie mentalne. Zmusisz swój mózg do innego rodzaju\naktywności od tego co robisz na co dzień jako Tech Writer.</li>\n<li>Zrozumiesz, że pisanie dokumentacji podczas kodowania nie jest do końca\nnaturalną rzeczą. Kiedy zatopisz się w kodowaniu, wchodzisz w tryb rozmowy z\nmaszyną i skupiasz się na rozwiązaniu problemu. Nie jest łatwo przełączyć się\nna tryb rozmowy z człowiekiem, czyli pisanie dokumentacji. Dlatego następnym\nrazem kiedy programista nie doda dokumentacji do swojego kodu, spojrzysz na\nniego łaskawszym okiem.</li>\n</ul>\n<h2>Dlaczego Python?</h2>\n<p>Python jest dobrym językiem, żeby rozpocząć przygodę z kodowaniem. Jego składnia\njest prosta i przejrzysta, dlatego pierwsze proste skrypty jesteś w stanie\nzacząć pisać szybko. To trochę jak mówienie po angielsku do komputera.\nUszczypliwi twierdzą wręcz, że składnia Pythona przypomina bardziej pseudokod\nniż prawdziwy kod. O ile dla programisty takie stwierdzenie może być obelgą i\nspowodować, że ucierpi na tym jego ego, o tyle dla Tech Writera jest to jak\nnajbardziej pozytywna rzecz, bo łatwiej jest się nauczyć takiej składni.\nSłyszałem kiedyś takie stwierdzenie, że łatwa składnia Pythona ułatwia skupienie\nsię na problemie, który chcemy rozwiązać zamiast na tym jak napisać kod.</p>\n<p>Jednak, żeby wszystko było jasne - Python nie jest prymitywny. To język, który\nma wiele twarzy. Jeśli potrzebujesz prostego skryptu, to możesz go napisać w\nrelatywnie krótkim czasie nie rozumiejąc dogłębnie wszystkich aspektów tego\njęzyka. Ale jeśli potrzebujesz napisać rozbudowaną aplikację, Python też to\npotrafi.</p>\n<p>Kiedyś przyszła mi do głowy taka analogia - Python dla Tech Writera jest jak\nMarkdown dla programisty. Nie zajmujesz się zawodowo programowaniem i kodowanie\njest dla Ciebie kolejnym narzędziem do osiągania dokumentacyjnych celów, dlatego\npotrzebujesz czegoś łatwego i przyjemnego. Tak samo jest w przypadku\nprogramistów. Ich głównym zadaniem jest programowanie, a nie pisanie\ndokumentacji, dlatego również potrzebują czegoś z czego można szybko zacząć\nkorzystać.</p>\n<h2>Jak będziemy się uczyć?</h2>\n<p>Python jak by nie było jest językiem. Co prawda programowania, ale nadal\njęzykiem. Każdy kto uczęszczał do szkoły miał okazję uczyć się (lub być uczonym)\njakiegoś języka. Dlatego chciałbym podejść do nauki Pythona jak do nauki języka\nangielskiego. Jednak w przeciwieństwie do tradycyjnej szkoły, w tym przewodniku\n\"gramatyką\" zajmiemy się tylko do takiego stopnia, żeby było wiadomo co się\ndzieje i żeby mieć poczucie komfortu w trakcie pisania kodu. Nie zrozum mnie\nźle, gramatyka jest ważna i jej znajomość jest jak najbardziej wartościowa, ale\nna etapie gdzie zaczynasz swoją przygodę z językiem skupimy się na\n\"konwersacjach\".</p>\n<p>Wskoczymy na głęboką wodę i od razu zaczniemy rozmawiać z komputerem. Na\npoczątku nie będziesz do końca rozumieć co mówisz, pewne zasady być może będą\ndla Ciebie niejasne, ale będziesz mieć poczucie, że uczysz się czegoś\npraktycznego i będziesz od razu widzieć efekty tej nauki. Czyli będzie dokładnie\ntak jak podczas nauki angielskiego poprzez konwersacje z native speakerem.\nZamiast uczyć się reguł kodowania w Pythonie, żeby potem błyszczeć w\ntowarzystwie wiedzą teoretyczną, stworzymy razem przykładową aplikację, dzięki\nktórej nauczysz się czegoś praktycznego i zobaczysz w jakich obszarach znajomość\nPythona może Ci pomóc w pracy Tech Writera. Zatem, nie przedłużając, przystąpmy\ndo kodowania.</p>\n"},{"pageId":"praktyka","pageTitle":"Przechodzimy do praktyki","pageContent":"<p>Być może z rozpędu czy też przyzwyczajenia przejście od razu do części\npraktycznej tego przewodnika wydało Ci się dobrym pomysłem. Jeśli tak się stało,\nto zachęcam Cię do przeczytania <a href=\"teoria.md\">części teoretycznej</a>, żeby\ndowiedzieć się jaki miałem cel pisząc ten przewodnik i jakie powinny być Twoje\noczekiwania w stosunku do tego co tu znajdziesz.</p>\n<h2>Co będziemy robić?</h2>\n<p>Jak to co? Kodować w Pythonie! 🙂</p>\n<p>W świecie dokumentacji do oprogramowania, istnieje wiele miejsc, gdzie\ntradycyjne \"kopiuj-wklej\" można potencjalnie zastąpić jakimś automatycznym\nrozwiązaniem, które odwali za nas brudną robotę.</p>\n<p>Wyobraź sobie taki scenariusz. Dostajesz przydział do projektu, w którym\nbędziesz bardzo blisko współpracować z programistami. Ustaliliście na samym\npoczątku, że za każdym razem kiedy programista zrobi zmianę w kodzie, która musi\nzostać udokumentowana, doda do folderu <code>docs</code> plik tekstowy z opisem zmian. Plik\nbędzie miał taką nazwę jak numer historyjki w systemie do śledzenia zadań. Na\nprzykład, jeśli historyjka ma numer <strong>PROJ-102</strong> i została stworzona po to, żeby\nprogramista naprawił błąd powodujący, że aplikacja zawieszała się na kilka\nsekund, a następnie okno aplikacji przesuwało się poza ekran, to programista w\nrepozytorium z kodem doda plik <code>docs\\PROJ-102.txt</code>, w którym będzie taka\ninformacja.</p>\n<p><em>PROJ-102.txt</em></p>\n<blockquote>\n<p>Naprawiliśmy błąd, który powodował, że aplikacja zawieszała się na kilka\nsekund, a następnie okno aplikacji przesuwało się poza ekran przez co stawało\nsię niewidoczne.</p>\n</blockquote>\n<p>Co kilka tygodni zespół publikuje nową wersję aplikacji wraz z aktualną\ndokumentacją, której częścią są <em>release notes</em> (noty wydania). Treść, która\ntrafia do <em>release notes</em> pochodzi z plików tekstowych, które dodają programiści\nkiedy zmieniają kod. Twoim zadaniem, jako Tech Writera, jest sprawdzanie\ninformacji w tych plikach, poprawianie ich, a na końcu wygenerowanie pliku HTML\nz gotowymi notami. Jest to prosty plik z tabelką przedstawiającą zmiany w\naplikacji. Chodzi o coś takiego.</p>\n<table>\n<thead>\n<tr>\n<th>Numer zgłoszenia</th>\n<th>Opis</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>PROJ-102</td>\n<td>Naprawiliśmy błąd, który powodował, że aplikacja zawieszała się na kilka sekund, a następnie okno aplikacji przesuwało się poza ekran przez co stawało się niewidoczne.</td>\n</tr>\n<tr>\n<td>PROJ-101</td>\n<td>Dodaliśmy nową funkcję, która pozwala na szybkie pobieranie zasobów sieciowych.</td>\n</tr>\n</tbody>\n</table>\n<p>Nie chcesz generować pliku HTML poprzez ręczne przeklejanie informacji z plików\ntekstowych i potem wprowadzanie pozostałych poprawek, dlatego szukasz bardziej\nsprytnego rozwiązania. Chcesz swój czas i energię przeznaczyć głównie na\nulepszanie informacji, które dostarczają Ci programiści, a proces publikowania\nkońcowego pliku chcesz przekazać maszynie.</p>\n<p>I to właśnie będzie nasz cel, który będziemy krok po kroku realizować w\nkolejnych sekcjach. Zbudujemy razem przykładowy generator treści, który pobiera\ninformacje z plików tekstowych, a następnie generuje docelowy plik HTML na\npodstawie szablonu.</p>\n"},{"pageId":"praktyka-przygotowanie","pageTitle":"Przygotowanie","pageContent":"<h2>Co nam będzie potrzebne?</h2>\n<p>Starałem się ograniczyć liczbę potrzebnych komponentów do minimum, żebyśmy mogli\nprzejść jak najszybciej do kodowania. Jednak pewnych rzeczy nie da się pominąć,\ndlatego będziesz potrzebować takiego oprogramowania.</p>\n<h3>Python</h3>\n<p>Pythona trzeba zainstalować. W niektórych systemach operacyjnych, może już być\nzainstalowany, ale istnieje spora szansa, że nie będzie to wersja, której\npotrzebujemy. A będziemy potrzebować wersji 3.7 lub nowszej.</p>\n<p>Instalatory znajdziesz na oficjalnej stronie Pythona (<a href=\"https://www.python.org/\">https://www.python.org/</a>).\nMożesz też zainstalować Pythona poprzez menedżera paczek w swoim systemie\noperacyjnym. Kolejną opcją jest użycie narzędzia pyenv\n(<a href=\"https://github.com/pyenv/pyenv\">https://github.com/pyenv/pyenv</a>). W przypadku Windowsa możesz także skorzystać z\ninstalacji poprzez Microsoft Store.</p>\n<p>Wybierz dogodną dla siebie metodę instalacji. Jeśli napotkasz jakieś problemy to\nnajlepiej poproś o pomoc kogoś kto ma doświadczenie z Pythonem albo poszukaj\ninformacji w internecie. Biorąc pod uwagę liczbę systemów operacyjnych,\npotencjalna liczba problemów z instalacją jest spora, dlatego nie byłbym w\nstanie pokryć w tym przewodniku każdej możliwej ścieżki.</p>\n<p>Bez względu na to jaką wybierzesz metodę instalacji, zwróć uwagę, żeby dodać\nPythona do zmiennych środowiskowych, czyli przypisać komendę <code>python</code> do Pythona\n3, którego zainstalujesz. Robi się to różnie w zależności od systemu\noperacyjnego i sposobu instalacji. Na przykład, jeśli instalujesz Pythona na\nWindowsie za pomocą instalatora pobranego z oficjalnej strony Pythona, na jednym\nz ekranów będziesz mieć opcję, żeby dodać Pythona do zmiennych środowiskowych\n(<code>PATH</code>).</p>\n<h3>Edytor tekstowy</h3>\n<p>Możesz użyć jakiegokolwiek edytora tekstowego, żeby kodować w Pythonie. Jednak\nzachęcam Cię do skorzystania z edytora, który wspiera Pythona. Ułatwi Ci to\nznacznie życie, bo taki edytor podpowie Ci podczas pisania jakie masz opcje,\nautomatycznie sformatuje Twój kod i da Ci znać jeśli coś będzie nie tak. Na\nszczęście nie ma problemu ze znalezieniem odpowiedniego edytora, który jest\ndarmowy. Nie chcę Ci narzucać niczego, ale w momencie pisania tego przewodnika\npopularnym i darmowym edytorem, który oferuje wsparcie dla Pythona jest Visual\nStudio Code od Microsoftu (<a href=\"https://code.visualstudio.com/\">https://code.visualstudio.com/</a>). Może ta opcja będzie\ndla Ciebie odpowiednia.</p>\n<p>Oprócz edytorów, możesz skorzystać z bardziej zaawansowanej opcji, czyli IDE\n(ang. <em>integrated development environment</em>). Przykładem może być PyCharm od\nJetBrains (<a href=\"https://www.jetbrains.com/pycharm/\">https://www.jetbrains.com/pycharm/</a>). Jednak na nasze potrzeby jest to\nza dużo. Nauczenie się obsługi IDE przyniesie Ci korzyści, ale na późniejszym\netapie nauki Pythona. Na tym etapie, polecam edytor tekstowy.</p>\n<h2>Kodowanie czas zacząć</h2>\n<p>Mam nadzieję, że instalacja Pythona i edytora nie przysporzyły Ci problemów i że\nTwój zapał jest taki sam albo większy jak w momencie rozpoczęcia czytania tego\nprzewodnika. Skoro mamy już wszystko gotowe to zabieramy się do pracy.</p>\n<p>Będziemy krok po kroku budować naszą aplikację. Pomimo tego, że ten przewodnik\njest napisany w języku polskim i nasze pliki tekstowe zawierają w sobie polski\ntekst, to nasz kod będziemy pisać po angielsku. Być może wyda Ci się to dziwne,\nale według mnie jest to bardziej naturalne i powszechne. Poza tym, dzięki temu,\nTwój kod będzie mógł bywać w świecie, bo Twoi anglojęzyczni znajomi też będą w\nstanie go zrozumieć.</p>\n<p>Jeśli chcesz od razu skoczyć na głęboką wodę albo po prostu jesteś ciekaw co tu\nsię wydarzy, przejdź do sekcji <a href=\"gotowa-aplikacja\">Gotowa aplikacja</a>.</p>\n"},{"pageId":"praktyka-1","pageTitle":"Krok 1: Stwórz folder dla generatora","pageContent":"<p>W dogodnej lokalizacji na swoim dysku, stwórz folder <code>rel_notes_generator</code>. W\ntym folderze będziemy dodawać kolejne zasoby potrzebne nam do zbudowania\ngeneratora.</p>\n"},{"pageId":"praktyka-2","pageTitle":"Krok 2: Dodaj przykładowe pliki tekstowe","pageContent":"<p>Stwórz folder <code>rel_notes_generator\\input</code>, a w nim dodaj dwa pliki tekstowe,\n<code>PROJ-101.txt</code> i <code>PROJ-102.txt</code>, z taką zawartością jak widać poniżej. Tymi\nplikami \"nakarmimy\" nasz generator. Dzięki temu będziemy mogli sprawdzić czy\ndziała tak jak tego chcemy.</p>\n<p><em>PROJ-101.txt</em></p>\n<blockquote>\n<p>Dodaliśmy nową funkcję, która pozwala na szybkie pobieranie zasobów\nsieciowych.</p>\n</blockquote>\n<p><em>PROJ-102.txt</em></p>\n<blockquote>\n<p>Naprawiliśmy błąd, który powodował, że aplikacja zawieszała się na kilka\nsekund, a następnie okno aplikacji przesuwało się poza ekran przez co stawało\nsię niewidoczne.</p>\n</blockquote>\n"},{"pageId":"praktyka-3","pageTitle":"Krok 3: Stwórz szablon dla pliku HTML","pageContent":"<p>Mamy już pliki tekstowe, z których pobierzemy treść naszych not wydania. Teraz\npotrzebujemy jeszcze szablonu, do którego wstawimy informacje pobrane z plików\ntekstowych. Stwórz plik <code>rel_notes_generator\\release_notes_template.html</code> z\ntakim kodem HTML.</p>\n<p><em>release_notes_template.html</em></p>\n<pre><code class=\"language-html\">&#x3C;!DOCTYPE html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\" />\n    &#x3C;title>Noty wydania&#x3C;/title>\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;table>\n      &#x3C;tr>\n        &#x3C;th>Numer zgłoszenia&#x3C;/th>\n        &#x3C;th>Opis&#x3C;/th>\n      &#x3C;/tr>\n      $release_notes\n    &#x3C;/table>\n  &#x3C;/body>\n&#x3C;/html>\n</code></pre>\n<p>Ten prosty plik zawiera tabelkę, która póki co ma tylko jeden wiersz z dwoma\nkolumnami (<code>Numer zgłoszenia</code> i <code>Opis</code>) oraz tajemniczy element\n<code>$release_notes</code>. Jest to element zastępczy, który zostanie zamieniony przez\nnasz generator na informacje pobrane z plików tekstowych. W kroku 5 poznasz\nkomponent Pythona, który będzie w stanie zrobić użytek z tego elementu.</p>\n"},{"pageId":"praktyka-4","pageTitle":"Krok 4: Stwórz plik dla kodu generatora","pageContent":"<p>Stwórz plik <code>rel_notes_generator\\rel_notes_generator.py</code>. Pliki zawierające kod\nPythona mają rozszerzenie <code>.py</code>. W tym pliku będzie znajdował się kod dla\nnaszego generatora, który napiszemy w kolejnych krokach.</p>\n"},{"pageId":"praktyka-5","pageTitle":"Krok 5: Dodaj linki do potrzebnych komponentów Pythona","pageContent":"<p>Python zawiera w sobie bogaty zestaw gotowych komponentów, z których możemy\nkorzystać od razu bez instalowania dodatkowego oprogramowania. Ten zestaw nazywa\nsię <strong>The Python Standard Library</strong>. Żeby móc skorzystać z jakiegoś komponentu\nmusimy go zaimportować w naszej aplikacji, czyli tak jakby dodać do niego link.\nMożemy to zrobić wpisując:</p>\n<pre><code class=\"language-python\">import nazwaKomponentu\n</code></pre>\n<p>albo</p>\n<pre><code class=\"language-python\">from nazwaKomponentu import nazwaElementu\n</code></pre>\n<p>Różnica jest taka, że w pierwszym sposobie importujemy cały komponent a w drugim\ntylko określone elementy, których akurat potrzebujemy.</p>\n<p>Nasz generator będzie korzystał z trzech elementów, które są w trzech różnych\nkomponentach. Dlatego na początku naszego kodu w pliku <code>rel_notes_generator.py</code>\nmusimy dodać takie linijki.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">from string import Template\nfrom pathlib import Path\nfrom shutil import rmtree\n</code></pre>\n<p>Z komponentu <code>string</code> importujemy element <code>Template</code>, który pozwala na obsługę\nszablonów. Będzie on nam potrzebny, żeby odpowiednio opakować informacje pobrane\nz plików tekstowych i potem je podstawić w odpowiednie miejsce w szablonie HTML.\nJak pamiętasz, w kroku 3 pojawił się element zastępczy <code>$release_notes</code>.\nDodaliśmy go do naszego szablonu po to, żeby komponent <code>Template</code> wiedział gdzie\nma wstawić właściwe informacje.</p>\n<p>Z komponentu <code>pathlib</code> importujemy element <code>Path</code>, dzięki któremu w elegancki\nsposób będziemy mogli ustawić w naszej aplikacji ścieżki do potrzebnych zasobów.</p>\n<p>Z komponentu <code>shutil</code> importujemy element <code>rmtree</code>, który pozwala na usuwanie\nfolderów, nawet jeśli nie są puste.</p>\n"},{"pageId":"praktyka-6","pageTitle":"Krok 6: Ustaw ścieżki do potrzebnych zasobów","pageContent":"<p>W naszym generatorze musimy ustawić trzy ścieżki w taki oto sposób.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">current_dir = Path(__file__).parent\ninput_dir = current_dir / 'input'\noutput_dir = current_dir / 'output'\n</code></pre>\n<p>Zanim przejdę do wyjaśnienia o co dokładnie tutaj chodzi, wspomnę tylko, że\nzmienne w Pythonie tworzymy poprzez przypisanie jakiejś wartości do nazwy. Na\nprzykład, jeśli chciałbym stworzyć zmienną <code>name</code>, która będzie przechowywać w\nsobie moje imię i nazwisko, to muszę zrobić to tak.</p>\n<pre><code class=\"language-python\">name = 'Michał Skowron'\n</code></pre>\n<p>W Pythonie możesz używać zarówno pojedynczych (<code>''</code>) jak i podwójnych (<code>\"\"</code>)\ncudzysłowów.</p>\n<p>Ale wróćmy do naszych ścieżek. Na początku, ustawiamy <code>current_dir</code> czyli\nścieżkę do folderu, w którym znajduje się nasz plik <code>rel_notes_generator.py</code>.\nRobimy to za pomocą elementu <code>__file__</code> dostępnego w Pythonie. Ten element\nprzechowuje ścieżkę do pliku. Dodając <code>.parent</code> mówimy Pythonowi, że chcemy w\nnaszej zmiennej zapisać nie ścieżkę do naszego pliku, tylko do folderu, w którym\nnasz plik się znajduje.</p>\n<p>Pewnie zastanawiasz się po co jest nam to potrzebne? Jest to ogólnie dobra\npraktyka. Korzystając z niej ułatwiamy sobie życie, bo nie musimy na sztywno\nwpisywać ścieżki do naszego pliku. Dzięki temu nie ma znaczenia gdzie znajduje\nsię nasz plik <code>rel_notes_generator.py</code>, bo Python sam sobie rozwiąże tę ścieżkę.\nTa ścieżka jest naszym punktem wyjścia dla kolejnych ścieżek. Na jej podstawie\nbudujemy ścieżkę do folderu <code>input</code>, w którym trzymamy pliki tekstowe i do\nfolderu <code>output</code>, w którym zapisujemy nasz końcowy plik HTML.</p>\n<p>Możliwe, że zastanawiasz się teraz czy nie dałoby się tego zrobić prościej i\nuniknąć tej szamanerii. Dałoby się, ale niekoniecznie byłoby to lepsze\nrozwiązanie. Gdybyśmy nie skorzystali z elementu <code>__file__</code>, musielibyśmy\nustawić ścieżki \"na piechotę\". Wyobraź sobie, że Twój plik\n<code>rel_notes_generator.py</code> znajduje się w <code>C:\\my-apps\\rel_notes_generator</code>. Więc\nustawiasz ścieżki na sztywno w taki sposób.</p>\n<pre><code class=\"language-python\">current_dir = 'C:\\my-apps\\rel_notes_generator'\ninput_dir = current_dir + '\\' + 'input'\noutput_dir = current_dir + '\\' + 'output'\n</code></pre>\n<p>Takie rozwiązanie na pierwszy rzut oka może Ci się wydawać całkiem w porządku,\nale niestety niesie ze sobą parę problemów. Generator będzie działał tylko wtedy\njeśli:</p>\n<ul>\n<li>Uruchomimy go na Windowsie</li>\n<li>Nasz folder projektu będzie nazywał się <code>rel_notes_generator</code> i będzie\nznajdował się w <code>C:\\my-apps</code>.</li>\n</ul>\n<p>Jeśli zmienimy nazwę folderu projektu albo przeniesiemy go w inne miejsce, to\nnasz generator przestanie działać. To dość spore ograniczenia, których możemy\nuniknąć stosując komponent <code>pathlib</code> i ścieżkę do folderu projektu, która sama\nsię automatycznie rozwiązuje.</p>\n"},{"pageId":"praktyka-7","pageTitle":"Krok 7: Dodaj funkcję do wyciągania informacji z plików źródłowych","pageContent":"<p>Teraz dodamy naszą pierwszą funkcję.</p>\n<p>Funkcja w kodzie to nic innego jak kawałek kodu, który wykonuje jakąś operację.\nBędzie nam ona potrzebna, żeby z naszych plików tekstowych pobrać ich nazwę i\nzawartość.</p>\n<p>Dodaj do pliku <code>rel_notes_generator.py</code> następujący kod.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">def get_release_notes(source_dir):\n    rel_notes = {}\n    for file in source_dir.glob('*.txt'):\n        rel_note_id = file.stem\n        with file.open() as f:\n            rel_note_text = f.read()\n        rel_notes[rel_note_id] = rel_note_text\n    return rel_notes\n</code></pre>\n<p>W Pythonie, tworzymy funkcję za pomocą słowa <code>def</code>. Następnie podajemy nazwę\nfunkcji i opcjonalnie w nawiasie określamy parametry, które funkcja przyjmuje.</p>\n<p>W naszym wypadku funkcja nazywa się <code>get_release_notes</code>. Żeby mogła wykonać\npoprawnie swoje zadanie, musimy podać jej ścieżkę do folderu, w którym znajdują\nsię pliki tekstowe (<code>source_dir</code>).</p>\n<p>Pierwsze koty za płoty. Idziemy dalej. Nasza funkcja ma za zadanie przejść przez\nwszystkie pliki i zebrać z nich nazwę i zawartość. Zgodnie z tym co zostało\nustalone z programistami w Twoim projekcie, nazwa pliku to numer zgłoszenia, a\nzawartość to opis wprowadzonych zmian w kodzie aplikacji. W związku z tym,\nwygodnie będzie nam zapisać informacje zebrane przez naszą funkcję w formie\nsłownika (<code>dict</code>), czyli takiego zbioru elementów <code>klucz: wartość</code>. W Pythonie,\nsłownik to jeden z najważniejszych typów danych, który jest bardzo często\nużywany.</p>\n<p>W naszym wypadku, taka para będzie wyglądać tak: <code>numer zgłoszenia: opis zmian</code>.\nNa początku dodajemy zmienną <code>rel_notes</code>, która będzie przechowywać pusty\nsłownik (<code>{}</code>). Potem ten pusty słownik wypełnimy danymi, które nasza funkcja\nzbierze.</p>\n<p>W folderze może znajdować się więcej niż jeden plik tekstowy, więc musimy zrobić\npętlę, która przejdzie po wszystkich plikach. Innymi słowy, mówimy Pythonowi,\nżeby dla każdego pliku (<code>for file</code>), który ma rozszerzenie TXT\n(<code>in source_dir.glob('*.txt')</code>):</p>\n<ol>\n<li>W zmiennej <code>rel_note_id</code> zapisał nazwę pliku (<code>file.stem</code>).</li>\n<li>Otworzył plik (<code>with file.open() as f</code>) i w zmiennej <code>rel_note_text</code> zapisał\njego zawartość, którą pobrał (<code>f.read()</code>).</li>\n<li>Do słownika dodał parę z numerem zgłoszenia i opisem zmian\n(<code>rel_notes[rel_note_id] = rel_note_text</code>).</li>\n</ol>\n<p>Kiedy pętla przejdzie po wszystkich plikach, funkcja zwróci nam wypełniony\nsłownik (<code>return rel_notes</code>). W naszym testowym środowisku, funkcja zwróci nam\ntaki słownik:</p>\n<pre><code class=\"language-json\">{\n  \"PROJ-101\": \"Dodaliśmy nową funkcję, która pozwala na szybkie pobieranie zasobów sieciowych.\",\n  \"PROJ-102\": \"Naprawiliśmy błąd, który powodował, że aplikacja zawieszała się na kilka sekund, a następnie okno aplikacji przesuwało się poza ekran przez co stawało się niewidoczne.\"\n}\n</code></pre>\n<p>Na tym etapie, tylko stworzyliśmy nową funkcję, ale jeszcze jej nie\nuruchomiliśmy. To zrobimy dopiero później.</p>\n"},{"pageId":"praktyka-8","pageTitle":"Krok 8: Dodaj funkcję generującą wiersze tabeli","pageContent":"<p>W poprzednim kroku zrobiliśmy całkiem sporo, ale to dopiero początek. Potrzebne\nnam będą jeszcze inne funkcje, żeby nasza aplikacja zrobiła wszystko co to\nchcemy, czyli stworzyła dla nas plik HTML z notami wydania.</p>\n<p>W tym kroku dodamy funkcję i prosty szablon, który pozwoli nam przerobić słownik\nna fragment kodu HTML. Będą to wiersze tabeli, które podstawimy w kolejnych\nkrokach do naszego szablonu HTML. Jak pamiętasz, szablon przygotowaliśmy w\nkroku 3.</p>\n<p>Na początek, dodaj taki mały szablon.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">rel_note_template = Template('''&#x3C;tr>\n&#x3C;td>$id&#x3C;/td>\n&#x3C;td>$description&#x3C;/td>\n&#x3C;/tr>\n''')\n</code></pre>\n<p>Szablon ma w sobie dwa elementy zastępcze, <code>$id</code> i <code>$description</code>, które\nbędziemy zamieniać odpowiednio na klucz i wartość ze słownika. Potrójny\ncudzysłów (<code>'''</code> lub <code>\"\"\"</code>) służy do tworzenia łańcuchów znaków, które zajmują\nwięcej niż jedną linijkę. Dla łańcuchów znaków, które nie wykraczają poza jedną\nlinijkę używa się pojedynczego cudzysłowu (<code>'</code> lub <code>\"</code>).</p>\n<p>Następnie dodaj kolejną funkcję.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">def generate_release_notes(release_notes):\n    rel_note_table_rows = ''\n    for id, description in release_notes.items():\n        rel_note_table_rows += rel_note_template.substitute(\n            id=id, description=description)\n    return rel_note_table_rows\n</code></pre>\n<p>Jej zadaniem będzie przekształcenie słownika we fragment kodu HTML. W poprzednim\nkroku analizowaliśmy poszczególne części składowe funkcji, więc pewnie ta\nfunkcja nie jest już dla Ciebie wielką niewiadomą. Jednak dla porządku przejdźmy\npo tym co się tutaj dzieje.</p>\n<p>Nasza funkcja o nazwie <code>generate_release_notes</code> przyjmuje jako parametr słownik\n(<code>release_notes</code>), w którym są pary <code>numer zgłoszenia: opis zmian</code>.</p>\n<p>Na początku, tworzymy zmienną <code>rel_note_table_rows</code>, której wartość to pusty\ntekst (<code>''</code>). W tej zmiennej zapiszemy nasze wiersze tabeli HTML, które\nwygenerujemy za pomocą naszego szablonu <code>rel_note_template</code>.</p>\n<p>Następnie, mówimy Pythonowi, żeby dla każdej pary (<code>for id, description</code>) w\nsłowniku (<code>release_notes.items()</code>):</p>\n<ol>\n<li>Wziął szablon <code>rel_note_template</code> i podmienił w nim element zastępczy <code>$id</code>\nna <code>id</code> ze słownika (czyli numer zgłoszenia) i zamienił element zastępczy\n<code>$description</code> na <code>description</code> ze słownika. Innymi słowy pobieramy ze\nsłownika numer zgłoszenia i opis zmian i wstawiamy je do szablonu\n(<code>rel_note_template.substitute(id=id, description=description)</code>).</li>\n<li>Dodał wygenerowany wiersz tabeli HTML do zmiennej, którą stworzyliśmy na\npoczątku (<code>rel_note_table_rows +=</code>).</li>\n</ol>\n<p>Kiedy pętla przejdzie po wszystkich parach w słowniku, funkcja zwróci nam\nzmienną z gotowymi wierszami tabeli (<code>return rel_note_table_rows</code>). W naszym\ntestowym środowisku, funkcja zwróci nam taki kod:</p>\n<pre><code class=\"language-html\">&#x3C;tr>\n  &#x3C;td>PROJ-101&#x3C;/td>\n  &#x3C;td>\n    Dodaliśmy nową funkcję, która pozwala na szybkie pobieranie zasobów\n    sieciowych.\n  &#x3C;/td>\n&#x3C;/tr>\n&#x3C;tr>\n  &#x3C;td>PROJ-102&#x3C;/td>\n  &#x3C;td>\n    Naprawiliśmy błąd, który powodował, że aplikacja zawieszała się na kilka\n    sekund, a następnie okno aplikacji przesuwało się poza ekran przez co\n    stawało się niewidoczne.\n  &#x3C;/td>\n&#x3C;/tr>\n</code></pre>\n<p>Dla przypomnienia dodam, że tak jak w poprzednim kroku, tylko stworzyliśmy nową\nfunkcję, ale jeszcze jej nie uruchomiliśmy. To zrobimy dopiero później.</p>\n"},{"pageId":"praktyka-9","pageTitle":"Krok 9: Dodaj funkcję zapisującą końcowy plik HTML","pageContent":"<p>To już ostatnia funkcja, której potrzebujemy. Jej zadaniem jest podstawienie\nwierszy tabeli do szablonu pliku HTML, a następnie zapisanie końcowego pliku\nHTML z notkami wydania. Dodaj taki kod do pliku <code>rel_notes_generator.py</code>.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">def write_release_notes(release_note_rows, target_dir):\n    if target_dir.exists():\n        rmtree(target_dir)\n    target_dir.mkdir()\n    with Path('release_notes_template.html').open() as rnt:\n        file_template = Template(rnt.read())\n    with (target_dir / 'release_notes.html').open('w') as rn:\n        rn.write(file_template.substitute(release_notes=release_note_rows))\n</code></pre>\n<p>Na początku funkcja sprawdza czy folder docelowy, w którym zapiszemy końcowy\nplik już istnieje (<code>target_dir.exists()</code>). Jeśli tak, to najpierw go kasuje\n(<code>rmtree(target_dir)</code>). Następnie, funkcja tworzy folder docelowy\n(<code>target_dir.mkdir()</code>). Te wszystkie kroki możemy wykonać w łatwy sposób dzięki\nkomponentom <code>pathlib</code> i <code>shutil</code>, które zaimportowaliśmy w kroku 5.</p>\n<p>Po przygotowaniu folderu docelowego, funkcja otwiera plik szablonu HTML\n(<code>with Path('release_notes_template.html').open() as rnt</code>) po czym przypisuje\nzawartość szablonu do zmiennej <code>file_template</code>\n(<code>file_template = Template(rnt.read())</code>).</p>\n<p>Następnie, funkcja tworzy pusty plik końcowy o nazwie <code>release_notes.html</code>\n(<code>with (target_dir / 'release_notes.html').open('w') as rn</code>). Ostatnia część to\nzamiana w szablonie HTML elementu zastępczego <code>$release_notes</code> na właściwe\nwiersze tabeli i zapisanie tego kodu HTML do pliku końcowego\n(<code>rn.write(file_template.substitute(release_notes=release_note_rows))</code>).</p>\n<p>Funkcja jest dość krótka, ale całkiem sporo się tutaj wydarzyło. To jest właśnie\njedna z zalet Pythona - zwięzła i czytelna składnia, dzięki której można na\nniewielkiej przestrzeni zawrzeć całkiem sporo logiki.</p>\n<p>Tak jak poprzednio, na razie tylko zdefiniowaliśmy funkcję. Teraz musimy ją\njeszcze uruchomić.</p>\n"},{"pageId":"praktyka-10","pageTitle":"Krok 10: Ostatnie szlify","pageContent":"<p>To już ostatnia prosta. Właściwie mamy już wszystko co nam potrzebne. Teraz\npozostaje nam uruchomić nasze funkcje.</p>\n<p>Żeby to zrobić, dodaj taki kod.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">if __name__ == '__main__':\n    collected_release_notes = get_release_notes(input_dir)\n    generated_table_rows = generate_release_notes(collected_release_notes)\n    write_release_notes(generated_table_rows, output_dir)\n</code></pre>\n<p>Pierwsza linijka, <code>if __name__ == '__main__'</code>, wygląda dość enigmatycznie. W\nPythonie w taki sposób określamy, że dany fragment kodu ma zostać uruchomiony\ntylko jeśli wywołamy plik <code>.py</code> jako skrypt z linii komend. Dzięki temu, ten\nfragment kodu nie zostanie wywołany jeśli zaimportujemy nasz plik <code>.py</code> do\ninnego pliku. Zapewne to wszystko brzmi dość zagadkowo, dlatego postaram się to\nrozjaśnić na przykładzie.</p>\n<p>Kod naszego generatora znajduje się w pliku <code>rel_notes_generator.py</code>. W\nwiększości przypadków będziesz uruchamiać generator z linii komend jak skrypt za\npomocą polecenia <code>python rel_notes_generator.py</code>. Kiedy to zrobisz, część kodu,\nktóra znajduje się pod <code>if __name__ == '__main__'</code> zostanie wykonana. Czyli\nwszystko się zgadza, to jest właśnie to o co nam chodzi.</p>\n<p>Po pewnym czasie, stworzysz kolejny generator, który będzie miał trochę inne\nfunkcje niż generator, który stworzyliśmy wspólnie. Jednak pewne części będą\ntakie same. Żeby nie pisać tego samego kodu jeszcze raz, możesz zaimportować\n<code>rel_notes_generator.py</code> do swojego nowego generatora w taki sam sposób jak\nimportowaliśmy komponenty w kroku 5. W tej sytuacji chcesz tylko zaimportować\nfunkcje z generatora, ale nie chcesz, żeby się uruchomiły. O tym kiedy je\nuruchomić, zdecydujesz w odpowiedniej części swojego nowego generatora. I\nwłaśnie użycie <code>if __name__ == '__main__'</code>, powoduje że funkcje się nie\nuruchomią. Podczas importu funkcji, wszystko co znajduje się poniżej tej linijki\nnie wykona się.</p>\n<p>Skoro już wiemy po co nam ten enigmatyczny fragment kodu, zobaczmy co znajduje\nsię pod nim. Najpierw, uruchamiamy funkcję <code>get_release_notes</code> na folderze\n<code>input</code>, czyli tam gdzie mamy nasze testowe pliki tekstowe. Dla przypomnienia,\nfunkcja wyciągnie nam nazwy i zawartość plików tekstowych. Wynik uruchomienia\nfunkcji przypisujemy do zmiennej <code>collected_release_notes</code>. Następnie,\nuruchamiamy funkcję <code>generate_release_notes</code>, która stworzy nam wiersze tabeli\nHTML z zawartości plików tekstowych, którą trzymamy w zmiennej\n<code>collected_release_notes</code>. Wygenerowane wiersze tabeli przypisujemy do zmiennej\n<code>generated_release_notes</code>. Ostatnia operacja, to uruchomienie funkcji\n<code>write_release_notes</code>, która zapisze to co mamy w zmiennej\n<code>generated_release_notes</code> do końcowego pliku HTML.</p>\n<p>Nasze noty wydania są gotowe!</p>\n"},{"pageId":"gotowa-aplikacja","pageTitle":"Gotowa aplikacja","pageContent":"<p>Udało się nam przejść przez wszystkie etapy tworzenia generatora. Poniżej\nkompletny kod naszej aplikacji.</p>\n<p><em>rel_notes_generator.py</em></p>\n<pre><code class=\"language-python\">from string import Template\nfrom pathlib import Path\nfrom shutil import rmtree\n\ncurrent_dir = Path(__file__).parent\ninput_dir = current_dir / 'input'\noutput_dir = current_dir / 'output'\n\nrel_note_template = Template('''&#x3C;tr>\n&#x3C;td>$id&#x3C;/td>\n&#x3C;td>$description&#x3C;/td>\n&#x3C;/tr>\n''')\n\n\ndef get_release_notes(source_dir):\n    rel_notes = {}\n    for file in source_dir.glob('*.txt'):\n        rel_note_id = file.stem\n        with file.open() as f:\n            rel_note_text = f.read()\n        rel_notes[rel_note_id] = rel_note_text\n    return rel_notes\n\n\ndef generate_release_notes(release_notes):\n    rel_note_table_rows = ''\n    for id, description in release_notes.items():\n        rel_note_table_rows += rel_note_template.substitute(\n            id=id, description=description)\n    return rel_note_table_rows\n\n\ndef write_release_notes(release_note_rows, target_dir):\n    if target_dir.exists():\n        rmtree(target_dir)\n    target_dir.mkdir()\n    with Path('release_notes_template.html').open() as rnt:\n        file_template = Template(rnt.read())\n    with (target_dir / 'release_notes.html').open('w') as rn:\n        rn.write(file_template.substitute(release_notes=release_note_rows))\n\nif __name__ == '__main__':\n    collected_release_notes = get_release_notes(input_dir)\n    generated_table_rows = generate_release_notes(collected_release_notes)\n    write_release_notes(generated_table_rows, output_dir)\n</code></pre>\n"},{"pageId":"praktyka-run","pageTitle":"Jak uruchomić generator?","pageContent":"<p>W kroku 10, pojawiła się już informacja jak wywołać plik <code>.py</code> z linii komend.\nJednak dla porządku, zamieszczam informację jak uruchomić generator:</p>\n<ol>\n<li>\n<p>Otwórz linię komend.</p>\n</li>\n<li>\n<p>Przejdź do folderu <code>rel_notes_generator</code>.</p>\n</li>\n<li>\n<p>Uruchom poniższą komendę.</p>\n<pre><code class=\"language-bash\">python rel_notes_generator.py\n</code></pre>\n<p>W folderze <code>output</code> pojawi się plik <code>release_notes.html</code> z gotowymi notami\nwydania.</p>\n</li>\n</ol>\n<blockquote>\n<p>W zależności od tego w jaki sposób Python został zainstalowany na Twoim\nkomputerze, komenda może się różnić. Na przykład, jeśli Python 3 nie został\ndodany do zmiennych środowiskowych Twojego systemu operacyjnego, może\nuruchomić się Python 2, który już wcześniej był zainstalowany na Twoim\nkomputerze. W innym wypadku, komenda może w ogóle nie zostać rozpoznana.\nMożesz wtedy spróbować użyć komendy <code>python3</code>.</p>\n</blockquote>\n"},{"pageId":"co-dalej","pageTitle":"Co dalej?","pageContent":"<p>Dotarliśmy do końca przewodnika. Dobra robota! Twoja pierwsza aplikacja w\nPythonie jest gotowa. Mam nadzieję, że to dopiero początek Twojej przygody z tym\njęzykiem programowania i że udało mi się przekonać Cię, że warto przyjrzeć się\nmu bliżej.</p>\n<p>Jeśli chcesz dowiedzieć się więcej o Pythonie i komponentach dostępnych w <strong>The\nPython Standard Library</strong> to polecam oficjalną dokumentację\n(<a href=\"https://docs.python.org/3/\">https://docs.python.org/3/</a>).</p>\n<p>Możesz też dalej pracować nad generatorem, żeby stał się jeszcze lepszy. Oto\nmoje propozycje.</p>\n<h2>Wsparcie dla Markdowna</h2>\n<p>Źródłem dla generatora są zwykłe pliki tekstowe. To niesie ze sobą pewne\nograniczenia. Na przykład, nie możemy dodawać formatowania takiego jak\npogrubienie czy kursywa. Jeśli potrzebujesz używać Markdowna w plikach\ntekstowych, możesz przyjrzeć się zewnętrznemu komponentowi <strong>Python Markdown</strong>\n(<a href=\"https://python-markdown.github.io/\">https://python-markdown.github.io/</a>). Nie jest on częścią <strong>The Python Standard\nLibrary</strong>, więc trzeba go zainstalować za pomocą narzędzia <code>pip</code>.</p>\n<h2>Bardziej zaawansowane szablony</h2>\n<p>Możesz zastąpić element <code>Template</code> z komponentu <code>string</code> bardziej zaawansowanym\nnarzędziem do tworzenia szablonów. Jedną z możliwości jest <strong>jinja2</strong>\n(<a href=\"https://jinja.palletsprojects.com/\">https://jinja.palletsprojects.com/</a>), która oferuje naprawdę sporo możliwości.</p>\n<h2>Lepszy wygląd pliku HTML</h2>\n<p>Warto pomyśleć nad dodaniem jakichś ładnych stylów do pliku HTML. Do tego\nbędziesz potrzebować znajomości CSS. Możesz przyjrzeć się bibliotece\n<strong>Bootstrap</strong> (<a href=\"https://getbootstrap.com/\">https://getbootstrap.com/</a>) rozwijanej przez Twittera. Jest ona\nbardzo popularna i pozwala niskim kosztem tworzyć atrakcyjne strony HTML.</p>\n<p>To już wiedza wykraczająca poza Pythona, ale na pewno przyda Ci się ona\nniejednokrotnie w przyszłości podczas tworzenia innych narzędzi.</p>\n"},{"pageId":"podziekowania","pageTitle":"Podziękowania","pageContent":"<h2>Paweł Kowaluk</h2>\n<p>Senior Technical Writer w Guidewire Software, mój dobry kolega i wieloletni\nwspółpracownik. Na co dzień razem pracujemy, a w wolnym czasie nagrywamy podcast\n\"Tech Writer koduje\".</p>\n<p>Dziękuję za recenzję, wsparcie i pomoc w przygotowaniu oprawy graficznej.</p>\n<p>Z Pawłem możecie się skontaktować za pomocą jego profilu na LinkedIn\n(<a href=\"https://www.linkedin.com/in/pawel-kowaluk/\">https://www.linkedin.com/in/pawel-kowaluk/</a>).</p>\n<h2>Sebastian Witowski</h2>\n<p>Konsultant i trener Pythona, mój znajomy z konferencji EuroPython 2019.</p>\n<p>Dziękuję za recenzję merytoryczną.</p>\n<p>W <a href=\"/blog/2020/03/24/14\">14. odcinku podcasta \"Tech Writer koduje\"</a>,\nrozmawialiśmy z Sebastianem o tym jak ustawić sobie środowisko do kodowania w\nPythonie i jakich błędów unikać zaczynając swoją przygodę z tym językiem\nprogramowania. Polecam też warsztat \"Modern Python Developer's\nToolkit\"(<a href=\"https://www.youtube.com/watch?v=WkUBx3g2QfQ&#x26;feature=youtu.be\">https://www.youtube.com/watch?v=WkUBx3g2QfQ&#x26;feature=youtu.be</a>), który\nSebastian przygotował w ramach konferencji PyCon US 2020.</p>\n<p>Z Sebastianem możecie się skontaktować za pomocą jego strony\n(<a href=\"https://switowski.com/\">https://switowski.com/</a>).</p>\n"}]},"__N_SSG":true}