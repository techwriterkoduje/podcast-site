{"pageProps":{"id":"dita-as-code","contentHtml":"<p>The title of this article may raise some eyebrows among our fellow content\nspecialists. We are aware that for some of them “DITA as code” may sound like an\noxymoron or be the last thing they would think of. Nevertheless, we decided to\nexplore this unconventional idea and we hope that you will join us on this\nexciting journey to discover new opportunities for the tech comm world.</p>\n<h2>Purpose of this article</h2>\n<p>This article aims to show how you can use DITA in the docs as code model. Unlike\nsome of the more accessible but simpler markup languages like Markdown, DITA\noffers a structured framework for content creation. At the same time, it has\nenough flexibility to fit modern workflows and create a collaborative space for\ncross-functional teams.</p>\n<p>We’re not saying that:</p>\n<ul>\n<li>DITA is a silver bullet for your content challenges and you should <strong>always</strong>\nuse it</li>\n<li>DITA is better than Markdown or other markup languages</li>\n<li>CCMSes are pure evil</li>\n</ul>\n<p>Instead, we want to convince you that:</p>\n<ul>\n<li>Thinking “either DITA <strong>or</strong> docs as code” is not right</li>\n<li>Docs as code is not reserved only for light markup languages and popular\nstatic site generators</li>\n<li>DITA can be cool</li>\n<li>DITA can still hold up in the face of rapidly changing modern technologies</li>\n<li>DITA can be used in the docs as code model and in some cases can give you more\nbenefits than simple markup languages</li>\n</ul>\n<h2>Tribute</h2>\n<p>Before we move on to the areas that we want to explore, we would like to stop\nfor a moment and pay tribute to the pioneers of the “DITA as code” idea - “DITA\nFor Small Teams”. This project hasn’t been active for a few years now but we\nstill encourage you to learn more about it at\n<a href=\"http://www.d4st.org/\">http://www.d4st.org/</a>.</p>\n<h2>What is “docs as code”?</h2>\n<p>Docs as code isn't a specific tool or solution. It's a philosophy, approach,\nmodel of work where you use the same techniques, tools and processes for\ndocumentation as you use for code. Typically in this model, you store sources of\nyour documentation in a version control system, you write your content using a\nmarkup language and you automate the process of building and publishing the\ndocs. However, there are no hard and fast rules on what tools and technologies\nconstitute a docs-as-code setup. That's why we are bold enough to claim that\nDITA can work well in such a setup.</p>\n<p>If you want to read more about docs as code, you can try these resources:</p>\n<ul>\n<li><a href=\"https://www.docslikecode.com/book/\">“Docs like code” by Anne Gentle</a></li>\n<li><a href=\"https://technology.blog.gov.uk/2017/08/25/why-we-use-a-docs-as-code-approach-for-technical-documentation/\">https://technology.blog.gov.uk/2017/08/25/why-we-use-a-docs-as-code-approach-for-technical-documentation/</a></li>\n<li><a href=\"https://www.writethedocs.org/guide/docs-as-code/\">https://www.writethedocs.org/guide/docs-as-code/</a></li>\n<li><a href=\"https://www.knowledgeowl.com/home/docs-as-code\">https://www.knowledgeowl.com/home/docs-as-code</a></li>\n</ul>\n<h2>Goals of the docs as code model</h2>\n<p>The docs as code approach sounds interesting but why should you bother to use\nit? What benefits do you get?</p>\n<p>Here are the main goals that docs as code tries to achieve:</p>\n<ul>\n<li>Better collaboration with developers</li>\n<li>Easier maintenance and faster delivery through automation</li>\n<li>More eagerness from developers to actively contribute to documentation - they\ncan create content in the same context as they write code</li>\n<li>Higher quality of documentation, as a result of all the points above</li>\n<li>Cost and time savings - you use the toolset that is already available in the\ncompany therefore you don't need to buy new tools, spend time on research\nbefore buying a new solution, or worry about being on your own with\ntech-comm-specific tools that no dev wants to touch.</li>\n</ul>\n<h2>Is DITA suitable for docs as code?</h2>\n<p>We believe that all the goals outlined above can also be achieved while using\nDITA as the authoring standard.</p>\n<p>These goals don’t necessarily require a lightweight markup language, like\nMarkdown. Nevertheless, docs as code and Markdown have become near synonyms.\n<a href=\"https://www.writethedocs.org/guide/docs-as-code/\">The description of docs as code on the Write The Docs page</a>,\nspecifically lists: “Plain Text Markup (Markdown, reStructuredText, Asciidoc)”.\nTom Johnson in his blog post about\n<a href=\"https://idratherbewriting.com/learnapidoc/pubapis_docs_as_code.html\">docs-as-code tools</a>\nalso states that working in plain text files is part of the docs-as-code model.</p>\n<p>This emphasis on using plain text markup draws the line between the docs-as-code\nmodel with a light markup, and a help authoring system with a binary or\nproprietary format and gives us the impression that there is nothing in between.</p>\n<p>The use of simple markup is further cemented by how a lot of dev teams add a\nMarkdown folder to their repository and render that markdown as the\ndocumentation website. Just look at examples for\n<a href=\"https://github.com/vercel/next.js/tree/canary/docs\">Next.js</a> and\n<a href=\"https://github.com/reactjs/reactjs.org/tree/main/content/docs\">React</a>.</p>\n<p>Why not DITA? We think part of the problem is that <strong>vendors “locked” DITA and\nDITA OT in their CCMSes.</strong> We hear about these systems all the time in the\ncontext of DITA. We have heard it so much that we started to think that DITA ==\nCCMS.</p>\n<p>CCMSes are meant to be powerhouses that provide an end-to-end solution for\nauthoring in DITA. Many companies purchased a CCMS to reduce the time required\nfor DITA implementation. We hear stories that using DITA without a CCMS is hard\nor even impossible. Is it really true or is it because these CCMSes were created\nbefore certain technologies were available? These new technologies, often freely\navailable, open new possibilities and allow for an easier adoption of any\nopen-source technology, including DITA.</p>\n<p>Let us restate this liberating truth: DITA is an open and free standard and\nnobody forces you to use it with a CCMS. The main publishing tool, DITA Open\nToolkit, is a vendor-independent, open-source implementation of a static site\ngenerator for the DITA standard. It’s actively developed, it follows trends, and\nis well documented. You can add the standard and the publishing tool to your dev\nworkflow at no monetary or licensing cost.</p>\n<p>As we hinted above, , DITA OT is a static site generator, just like Jekyll or\nHugo. Granted, it is unique because you need to know XSL to work with it, so the\nlearning curve may be a little steeper. But it’s still just an engine that\ntransforms one format into another. And so, you are free to use DITA OT in a\ndocs as code setup like you would Jekyll or Hugo. You can use a free source\ncontrol system, a free editor, and a free CI/CD pipeline.</p>\n<p>It’s worth mentioning that DITA OT also supports Markdown as an authoring\nformat.</p>\n<h2>Tools</h2>\n<p>Let's look at tools which allow you to adopt DITA in the docs as code model.</p>\n<h3>Content authoring</h3>\n<p>In a \"typical\" docs-as-code setup, not too much attention is devoted to this\npart. Since you use a simple markup language, like Markdown, you don't need a\ndedicated doc editor. A text editor with a plugin will do the job.</p>\n<p>If you use DITA, it can be a little more complex. Of course, you can create DITA\ncontent in a simple text editor, but it won't get you far and your productivity\nwill probably be lower. Authoring content in DITA requires a more robust and\npowerful tool. In fact, writing DITA content is more like coding, so you need\nsomething that is closer to an IDE than a text editor. A good example of an IDE\nwhich supports DITA is Oxygen XML.</p>\n<p>However, you can also use an IDE like IntelliJ or Eclipse, and it requires very\nlittle setup. You can even use a rich code editor, like Visual Studio Code.\nThese solutions may mean you are less productive than with a dedicated DITA\neditor, but they can be free, and are a lot better than a simple text editor.\nThey also have the advantage of being well-integrated into coding environments\nand come equipped with tools for version control and a variety of other\nchallenges.</p>\n<h3>Version control system (VCS)</h3>\n<p>You can use any of the VCSes available on the market. The most popular VCS among\nsoftware development teams is git. You want to adopt the docs-as-code philosophy\nto be as close to your devs as possible, so it is likely you will use git\nprovided by services like GitHub, Bitbucket or GitLab. Git can have a steep\nlearning curve but it’s a great tool and it’s definitely worth investing your\ntime to learn it.</p>\n<h3>Static site generator</h3>\n<p>The bad news is that you don't have a choice here. The only free and\nvendor-independent tool that enables you to transform DITA into other formats is\nDITA Open Toolkit. It's a golden standard and many CCMSes use this tool under\nthe hood. The <strong>good</strong> news is that it's a solid and actively-developed tool\nwith exhaustive documentation and its maintainers try to keep pace with\ntechnology trends. For example, DITA OT offers an official Docker image and\nsupport for Markdown.</p>\n<p>You can extend the tool by adding your own plugins. If you know XSL and Java,\nyou can build some really powerful stuff. Just look around\n<a href=\"https://www.dita-ot.org/plugins\">the official plugin registry</a> to see what’s\nalready available. Or, if you prefer, you can use one of the existing output\nformats and modify it to suit your needs. One option could be to configure the\nDITA OT HTML5 output with CSS and JavaScript until it becomes a fully-fledged\nstatic site in its own right. Another option is to consume the HTML5 output into\nyour existing website or web CMS and integrate seamlessly into a publication\npipeline that already exists at your company.</p>\n<p>Having just one option for selecting a generator can definitely raise some\nobjections. If you use Markdown, you have a plethora of options. But when you\ndecide to use restructuredText, the number of available options drops down\nsignificantly, and you have two or maybe three engines to choose from. Maybe\nit's some kind of mysterious law of nature - the number of available generators\ndecreases as the complexity of the markup language increases.</p>\n<h3>Local builds</h3>\n<p>You can build DITA locally from your command line. At first, installing the DITA\nOpen Toolkit may seem like a daunting task. In reality, it’s as simple as, or\neven simpler than, installing a regular static site generator. For example, the\n<a href=\"https://jekyllrb.com/docs/installation/\">installation instructions</a> for Jekyll,\none of the most popular generators, tell you that you need Ruby, RubyGems, GCC\nand Make. On the other hand, DITA Open Toolkit requires only Java (JRE or JDK),\nand maybe HTML Help Workshop if you want to generate Microsoft CHM Help. You can\nalso install DITA OT via Homebrew or use an official Docker image.</p>\n<p>Another option is to use transformation scenarios in your DITA IDE. For example,\nOxygen XML offers this feature, and does not ask you to install anything extra.</p>\n<h3>Automatic testing</h3>\n<p>There are two major areas of testing - making sure the documentation is\npublished successfully and making sure the content is right.</p>\n<p>The first area is familiar to people who maintain websites. You need to make\nsure your content was published successfully which you can achieve by reviewing\ndifferences in snapshots between the previous version and the current version.\nYou also need to check whether all links work, all images display, and all\naccessibility and performance goals are met. Finally, you make sure that your\nsite is discoverable by web crawlers, if that’s a concern.</p>\n<p>The second area is more familiar to technical writers. Before you publish your\ncontent, you want to make sure it meets internal standards of quality\n(styleguide, correct terminology, spelling and grammar). To achieve that, you\ncan run a series of tests that will flag potential issues, or sometimes maybe\neven fix them.</p>\n<p>The most popular tool to verify “XML correctness” of DITA is Schematron which\ncan help you check how you use XML markup in your documents. You can integrate\nSchematron with the Oxygen XML editor, or run it at specified times, like when\nyou push content to a git branch. Schematron is a great way to enforce your\nstyleguide. It can check if your document follows rules like “do not create\nlists with one item” or “always put a path-like string of characters into a\nfilepath tag”. You can also add “quick fixes” to Schematron - small\ntransformations that change existing content into compliant content.</p>\n<p>To check spelling, grammar, punctuation, and other language-related issues, you\ncan use a free program like LanguageTool, or integrate with a paid product, like\nAcrolinx. You could even integrate something like Grammarly with your text\neditor. In addition, you might want to invest in a command line tool that can\nmeasure the readability score of your documents.</p>\n<p>It might be a little more tricky to develop something for DITA, because you\nwould have to get rid of DITA tags, and perhaps even segment your content\nproperly. For example, text in a uicontrol tag is still part of the same\nsentence, but an sli tag means a new item in a simple list. Also, some tags do\nnot need spell checking, like codeph which is meant to contain code, not\nlanguage.</p>\n<p>You may have better results if you check the readability of your HTML output.\nThe first major advantage of that is you are looking at text which is filtered\nby your ditaval and put together from all content references and so on.\nSecondly, there are a variety of tools that understand HTML, for example\n<a href=\"https://www.npmjs.com/package/readability-checker\">a tool called readability-checker on NPM</a>.</p>\n<p>You also want to make sure it reflects the product correctly. That last part is\nwhere DITA can truly shine because of its semantics. It gives you the power to\ncreate various tests that you wouldn’t be able to use with lightweight markup\nlanguages. For example, you can test if the properties that you list in the docs\nactually exist in the config of your application. Or you can run the commands\ndescribed in your docs and make sure they achieve the results you promise.\n<a href=\"https://github.com/techwriterkoduje/dita-semantic-tests\">You can see an example implementation of semantic tests here</a>.</p>\n<h3>Content review</h3>\n<p>Since we are working with DITA as code and we are in a version control platform\nlike Github, along with our friends, software developers, architects, and\nproduct owners, we are already part of the code review process, we just have to\ntake advantage of it. A typical way of reviewing code is through pull requests,\nand we can review document sources in the same way. Github, Bitbucket, Gitlab,\nand other platforms come with features which allow us to comment on code,\napprove or reject pull requests, and prevent merging if tests are not passed.</p>\n<p>Granted, DITA is a complex markup language which can make it harder to read than\nsomething as simple as Markdown. However, our reviewers in a software\ndevelopment process are people with a high level of technical sophistication,\nand they are usually able to read XML without any problems. DITA becomes\nchallenging only when there are a lot of content references to parse, but this\ncan work, as our reviewers get used to the markup and learn how DITA works.</p>\n<h3>Automatic publishing</h3>\n<p>You can use the same tools and workflows for DITA as for any other markup\nlanguage. A great advantage of working in a software company is that you\nprobably already have a CI/CD solution that you can plug your docs into. Talk to\ndevelopers and devops engineers in your organization to see what options you\nhave. Let machines do the cumbersome work of generating the output and\npublishing it to the server.</p>\n<h2>What about reuse?</h2>\n<p>In the docs as code philosophy, there's no place for a CCMS. However, one of the\nmost useful aspects of a CCMS is how it helps with reuse . When you switch to a\ngit-based solution, this feature is no longer available. So what can you do to\nmake up for this loss?</p>\n<p>Before we jump into devising a technical solution to this challenge, let's think\nabout reuse itself. We often hear that it's very beneficial and gives you\nnothing but advantages. But the truth is that content reuse comes with\nchallenges. You need to decide how granular your reuse should be. Is reusing\ntopics enough? Or maybe it would be better to reuse paragraphs?</p>\n<p>You also need to think how widespread reuse needs to be. Across one document?\nAcross a document family? Across all documents? Each option has its pros and\ncons. For example, reusing content across all documents may seem like a good\nidea, but after some time you will realize that it's harder and harder to keep\nthe content generic enough to fit all scenarios. Also, every change is more\nexpensive because you need to analyze it from the perspective of every place the\ncontent is used.</p>\n<p>Taking all these factors into account, it may be possible to address content\nreuse needs by simply making a smart decision when dividing content into git\nrepos. For example, you can keep all docs belonging to the same product family\nin one repo. This way, you can reuse content between specific docs. In this\nscenario, your IDE, like Oxygen XML, will help you with renaming and moving\nresources without breaking stuff. Working this way is very similar to coding.\nYou have your software project cloned locally, you use IDE to write and edit\ncode without breaking things.</p>\n<p>But just like with a software project, there comes a moment when you need to use\nan external library, that is content stored outside your project. How can you\nhandle this requirement? The same way you would handle it in a software\nproject - by using dependency management.</p>\n<p>Your document is a project that requires some external resources to build\nproperly. In case of a software project, you have libraries available in\ndifferent repositories, like Artifactory or Maven, from which you download them\nand then use them in your code. You need to do the same for your documents. If\nyou need to use some assets, like common topics or images, across different\ndocuments stored in separate repositories, create a place where you will publish\nthese assets and then add them as a dependency to your document.</p>\n<p>We use DITA OT to build the document. It's like using Gradle to build a Java\nproject. We could write a plugin for the toolkit that downloads the assets\nbefore building the document. DITA OT offers many extension points where we can\nadd this task.</p>\n<p>Another option that you can consider is git submodules. You create a repository\nwith common assets and then add this repository as a submodule to the git\nrepository that stores source files for the document. After that, you can pull\nchanges to the linked submodule when you pull changes for your document. This\nsolution has one advantage over using a plugin for DITA OT - the shared\nresources are available at the time of editing the document.</p>\n<h2>What about link management?</h2>\n<p>Even without a CCMS, link management is an area where your “DITA IDE” shines.\nSimilar to IDEs used for writing code, Oxygen XML offers some refactoring\noptions that help you manage links. For example, the option for renaming a\nresource, like a topic, isn’t limited to changing the name of the resource. It\ncan also update all references for the resource.</p>\n<p>An IDE can help us with managing links at editing time. On top of that, we need\nother mechanisms that catch invalid links at other stages of the content\ndelivery process.</p>\n<p>At the time of committing changes, we can use a pre-commit hook in git to run a\nscript that automatically validates all the links in the repository and then\nblocks the commit if it finds any issues.</p>\n<p>We can also create validation builds that run when you create a pull request.\nThe policy can be configured to prevent merging changes if the validation build\nfails. This gives you another safety mechanism that protects you against\npublishing broken content. Validation builds can be part of you automatic\ntesting.</p>\n<h2>Example setup for DITA as code</h2>\n<p>Here’s an example “recipe” for the toolset that you could use in the DITA as\ncode model:</p>\n<ul>\n<li>Content authoring -\n<a href=\"https://www.oxygenxml.com/xml_author.html\">Oxygen XML Author</a> with the git\nplugin</li>\n<li>Version control system - <a href=\"https://git-scm.com/\">git</a> through\n<a href=\"https://bitbucket.org/\">Bitbucket</a></li>\n<li>Static site generator - <a href=\"https://www.dita-ot.org/\">DITA Open Toolkit</a> with\ncustom plugins, used in a Docker image</li>\n<li>CI/CD solution - <a href=\"https://www.jetbrains.com/teamcity/\">TeamCity</a></li>\n<li>Testing tools - <a href=\"https://www.schematron.com/\">Schematron</a>,\n<a href=\"https://docs.errata.ai/\">Vale</a>,\n<a href=\"https://github.com/techwriterkoduje/dita-semantic-tests\">custom validators written in Python</a></li>\n<li>Hosting solution - a <a href=\"https://nodejs.org/en/\">Node.js</a> server serving static\nHTML5 pages from an <a href=\"https://aws.amazon.com/s3/\">S3</a> bucket,\n<a href=\"https://www.elastic.co/elasticsearch/\">Elasticsearch</a></li>\n</ul>\n<p>We aren’t in any way sponsored by or associated with the providers of these\ntools. We simply want to give you something practical that complements the\ntheoretical description of the tools that we provided in the previous sections.\nWe have experience working with these solutions, so we know that this setup\nworks well for the DITA as code model.</p>\n<h2>DITA as code - what’s the catch?</h2>\n<p>DITA as code has its advantages but that’s just one side of the story. To our\nknowledge, so far nobody has invented a silver bullet for the content delivery\nprocess and DITA as code is no exception.</p>\n<p>If you want devs to contribute to the documentation, they may be reluctant to\nuse an XML standard. They are more inclined to use Markdown and you may have a\nhard time convincing them to change their mind. Their reluctance may in turn\ncreate a temptation to delegate all content-related tasks to tech writers; they\nalready know the content delivery system inside-out so they are able to make\nchanges faster and better, right?</p>\n<p>But there’s hope. At the <a href=\"http://soapconf.com/\">soap!</a> 2019 conference, Panny\nLuo in her talk\n<a href=\"https://www.youtube.com/watch?v=2R-8e_GtM0Y&#x26;list=PLUY0lajb-kiaIbF6clQaxTp2lwqmrDDC5&#x26;index=4\">“Content as Code: A manager’s perspective”</a>,\nshowed us how her organization managed to implement the DITA as code model and\nhow content specialists collaborated with devs. If you have a <strong>strong business\ncase</strong> for using DITA at your organization, e.g., reuse, more granular control\nover your content, robust semantic options - you may be able to convince all the\nstakeholders to play along.</p>\n<p>A big catch of DITA as code is that you have to code a lot. Maintain your\ndevelopment infrastructure, localization, and publication. There are tools that\ncan help, but you have to customize them and know how to use them.</p>\n<p>DITA as code is also harder for contributors (both writers and reviewers) who\nare less technical. A content management system comes with a streamlined user\ninterface, kind of like writing Word documents. This creates a familiar\nexperience to most people and is easy to learn for newcomers. When maintaining\nDITA as code, the contributors have to know the principles of VCS, understand\ntheir development pipeline, and troubleshoot daily problems with both their\ncomputers and their infrastructure.</p>\n<p>When you write content Markdown, you can pick and choose which editor you want\nto use. You have plenty of options, many of them free. When you use DITA, it’s\nquite the opposite. You only have a few options and the best ones aren’t free.\nIn a big organization this cost may not be significant but in smaller companies\nit can be a deal breaker.</p>\n<h2>Conclusion</h2>\n<p>Here are the key takeaways from this article:</p>\n<ul>\n<li>DITA can be used in the docs as code model - we have done it and it works.</li>\n<li>In some areas, DITA can offer more than lightweight markup languages, like\nbetter reuse possibilities and semantics that can be used for testing</li>\n<li>DITA as code is not a silver bullet and comes with challenges, like a small\nselection of content authoring tools and a steeper learning curve for\nnon-technical users than Markdown</li>\n<li>You need to weigh all the pros and cons before deciding if the DITA as code\nmodel is the right fit for you and your team.</li>\n</ul>\n","title":"DITA as code - a modern approach to the classic standard","episodeId":null,"description":"This article aims to show how you can use DITA in the docs as code model"},"__N_SSG":true}